\documentclass[11pt,a4paper]{article}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{xcolor}
\usepackage[
    colorlinks=true,
    linkcolor=black,
    citecolor=black,
    urlcolor=blue,
    bookmarks=true,
    bookmarksnumbered=true,
    pdfborder={0 0 0}
]{hyperref}
\usepackage{listings}
\usepackage{fancyhdr}

% Section formatting
\usepackage{titlesec}
\titleformat{\section}
  {\normalfont\Large\bfseries}{\thesection}{1em}{}[\titlerule]
\titleformat{\subsection}
  {\normalfont\large\bfseries}{\thesubsection}{1em}{}
\titleformat{\subsubsection}
  {\normalfont\normalsize\bfseries}{\thesubsubsection}{1em}{}

% Adjust spacing
\titlespacing*{\section}{0pt}{3.5ex plus 1ex minus .2ex}{2.3ex plus .2ex}
\titlespacing*{\subsection}{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}
\titlespacing*{\subsubsection}{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

% Better paragraph spacing
\setlength{\parskip}{0.5em}
\setlength{\parindent}{0pt}

% Page geometry
\geometry{margin=1in}
\setlength{\headheight}{14pt}

% Code listing settings
\lstset{
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{red},
    breaklines=true,
    frame=single,
    numbers=left,
    numberstyle=\tiny\color{gray}
}

% Header and footer
\pagestyle{fancy}
\fancyhf{}
\rhead{Database Security - SQL Injection}
\lhead{DFD Synopsis}
\rfoot{Page \thepage}

% Title information
\title{\textbf{SQL Injection Defense Mechanisms}\\
\large A Comparative Study Across Programming Languages and Frameworks}
\author{Mikkel Bak Markers}
\date{\today}

% Document
\begin{document}

\maketitle
\thispagestyle{empty}

\begin{abstract}
    In the darkest corners of the web, frightful worms and horrifying hacks
    are concocted. 
    Still, between the daemons and the dogs,
    a simple threat persists: SQL injection. 
    This investigation will uncover
    how these abominable beasts penetrate the otherwise impregnable
    defenses of modern applications. 
    By comparing the defensive mechanisms
    across C\#, Python, and Node.js ecosystems, we aim to shine light on
    how best to thwart these attacks, while still maintaining developer
    productivity and application performance. 
    Through surreptitious toils,
    we shall reveal which combination of language and framework offers
    the most stalwart protection against SQL injection, and provide
    ample and empirical evidence to the wary developer.
    [REMEMBER WHAT MUST BE DONE in about 250 words]
\end{abstract}

\newpage
\tableofcontents
\newpage

\section{Introduction}
% The ancient evil persists - why does SQL injection still plague our applications?

Despite decades of awareness and countermeasures, SQL injection remains 
among the most critical vulnerabilities in web applications, consistently 
ranking in OWASP's Top 10 security risks \cite{OWASP_Top10}. These attacks 
exploit insufficient input validation and sanitization, allowing malicious actors to 
manipulate database queries and compromise data integrity, confidentiality, 
and availability \cite{Halfond2006,OWASP_SQLi}.

While the fundamental defensive principle of ``never trust user input'' is well 
established, the practical implementation varies dramatically across 
programming ecosystems. This investigation conducts a comparative analysis 
of SQL injection defense mechanisms in three widely-adopted languages: 
C\# (.NET), Python, and Node.js.
We examine not only how robust the security is 
in each approach, but also the developer experience and performance implications 
that influence real-world adoption of secure practices.

\subsection{Motivation}
% Why this investigation matters - the curse is real
The urgency of this investigation is underscored by the continued prevalence 
and cost of SQL injection attacks. 
The financial carnage remains staggering: 
IBM's 2023 Cost of a Data Breach Report reveals the average data breach 
costs organizations \$4.45 million USD, with healthcare sector breaches 
averaging \$10.93 million, the highest of all industries\cite{ResilientX_IBM2023}. 
Web application attacks remain a prime threat vector across critical sectors 
including healthcare, finance, and public administration\cite{ENISA_ThreatLandscape2023}, 
with these attacks accounting for a substantial portion of breach 
incidents\cite{Verizon_DBIR2023}.

Still, developers 
continue to unknowingly introduce SQL injection vulnerabilities through 
framework misuse, inadequate training, or prioritizing speed over security. 
The choice between security and developer productivity need not be binary, 
yet the persistence of these attacks suggests a fundamental disconnect 
between secure coding principles and practical implementation.

This comparative study addresses a critical gap: while individual language 
communities document their own defensive patterns, cross-language analyses 
revealing which ecosystems make secure code the \textit{default} rather than 
the \textit{exception} remain scarce.
For organizations selecting technology 
stacks, understanding how language design and framework architecture influence 
security outcomes is not merely academic; it directly impacts their risk exposure.

Personally, the perpetual arms race between security mechanisms and 
exploitation techniques fascinates me. 
Developers strive to build secure 
applications under tight deadlines, while attackers continuously probe for 
weaknesses to exploit.
This investigation reveals which languages and frameworks 
best empower developers to safeguard their applications against SQL injection 
without sacrificing productivity or imposing excessive complexity.

\section{Problem Statement}
% The precise nature of our inquiry
While existing literature provides insight into the mechanics of SQL injection 
and general prevention strategies, there is a lack of comparative analysis 
across different programming languages and frameworks. This investigation 
addresses that gap by examining which language-framework combination provides 
the most robust and simultaneously developer-friendly defense against 
SQL injection attacks.

\textbf{Research Question:} 
How do defensive mechanisms against 
SQL injection differ across C\#, Python, and Node.js ecosystems, 
and which language/framework combination provides the most robust 
protection while minimizing developer friction and performance overhead?

\subsection{Sub-questions}
% Supporting inquiries that guide our investigation
\begin{itemize}
    \item What are the built-in protections each language provides?
    \item How easy is it for developers to accidentally introduce vulnerabilities?
    \item What is the performance cost of proper defensive measures?
    \item Which approach is most resistant to misuse?
\end{itemize}

\section{Methodology}
% Our investigative approach

This investigation employs a comparative implementation-based methodology,
building equivalent web applications in three different languages
to evaluate how each handles simulated SQL injection attacks.


\subsection{Research Approach}

The theoretical foundation draws from established security literature,
including OWASP's SQL Injection Prevention guidelines\cite{OWASP_SQLi} and
academic research on attack classification\cite{Halfond2006}. We supplement
this with official framework documentation for Entity Framework (.NET),
SQLAlchemy (Python), and Sequelize (Node.js) to understand idiomatic secure
patterns in each ecosystem. The implementation follows industry-standard
secure development practices while intentionally creating vulnerabilities
to demonstrate common pitfalls developers encounter.

\subsection{Implementation Strategy}

We implement three equivalent REST APIs, each providing authentication and
data query endpoints that interact with a SQL Server database. 
For each ecosystem, we develop two versions: a vulnerable baseline using
unsafe string concatenation or interpolation, and a secured implementation
employing parameterized queries and ORM frameworks. 
The C\# implementation uses ASP.NET Core with Entity Framework, Python uses Flask with SQLAlchemy,
and Node.js uses Express with Sequelize. 
This approach allows direct comparison of both the security 
vulnerabilities introduced through common
mistakes and the protective mechanisms each framework provides.

\subsection{Evaluation Criteria}

\subsubsection{Security Robustness}

Security evaluation tests each implementation against common SQL injection
attack vectors including union-based attacks, boolean-based blind injection,
and time-based blind injection.
We assess both the vulnerability of baseline
implementations and the effectiveness of defensive measures in secured versions.
Additionally, we evaluate how easily developers can accidentally introduce
vulnerabilities through framework misuse or misunderstanding.

\subsubsection{Developer Experience}

Developer experience assessment examines code verbosity, pattern clarity,
and cognitive load required to implement secure database interactions. 
We analyze the learning curve for each framework's security features, the quality
and accessibility of documentation, and how naturally secure patterns emerge
from idiomatic code. Special attention is given to compile-time versus
runtime error detection and how type systems influence security.

\subsubsection{Performance Overhead}

Performance evaluation measures response time for equivalent operations across
all three implementations, comparing vulnerable baseline versions against
secured implementations to quantify the overhead of proper defensive measures.
We conduct load testing to assess scalability characteristics and identify
performance bottlenecks specific to each language's database interaction model.

\subsection{Test Environment}

All implementations connect to Microsoft SQL Server 2022 running locally.
The C\# implementation uses .NET 8 with Entity Framework Core 8, Python
uses version 3.12 with Flask 3.0 and SQLAlchemy 2.0, and Node.js uses
version 20 LTS with Express 4.18 and Sequelize 6.35. Security testing
employs both manual payload injection and automated testing with sqlmap.
Performance measurements use Apache Bench for consistent load generation
across all implementations.

\section{Analysis \& Results}
% The meat of our investigation - theory meets practice

\subsection{Theoretical Foundation}
% SQL injection mechanisms briefly explained
% Defense categories: parameterized queries, ORMs, input validation
% Why language design matters

\subsection{C\# and Entity Framework}
% Implementation details

\subsubsection{Vulnerable Implementation}
% Code example showing string concatenation vulnerability
% Why it's easy to make this mistake

\subsubsection{Secured Implementation}
% Parameterized queries with ADO.NET
% Entity Framework LINQ approach
% Analysis of type safety and compile-time protections

\subsubsection{Evaluation}
% Security robustness findings
% Developer experience observations
% Performance measurements

\subsection{Python and SQLAlchemy}
% Implementation details

\subsubsection{Vulnerable Implementation}
% Raw SQL with string formatting vulnerability
% Common pitfalls in Python web development

\subsubsection{Secured Implementation}
% Parameterized queries with psycopg2/pyodbc
% SQLAlchemy ORM approach
% Analysis of Python's dynamic typing implications

\subsubsection{Evaluation}
% Security robustness findings
% Developer experience observations
% Performance measurements

\subsection{Node.js and Sequelize}
% Implementation details

\subsubsection{Vulnerable Implementation}
% Template literal injection vulnerability
% The dangers of JavaScript's flexible string handling

\subsubsection{Secured Implementation}
% Parameterized queries with native drivers
% Sequelize ORM approach
% Analysis of JavaScript's type system challenges

\subsubsection{Evaluation}
% Security robustness findings
% Developer experience observations
% Performance measurements

\subsection{Cross-Language Comparison}
% Bringing it all together

\subsubsection{Security Comparison}
% Which approach is hardest to misuse?
% Compile-time vs runtime protections
% Framework abstractions and their trade-offs

\subsubsection{Developer Experience Comparison}
% Code verbosity and clarity
% Ease of learning and applying secure patterns
% Documentation and ecosystem support

\subsubsection{Performance Comparison}
% Response time analysis
% Overhead of defensive measures
% Scalability considerations

\section{Conclusion}
% What knowledge have we gained from this descent?

\subsection{Summary of Findings}
% Key discoveries from the investigation
% Which language/framework excels in which dimension
% Trade-offs between security, usability, and performance

\subsection{Answering the Research Question}
% Direct response to the problem statement
% Confirmation or rejection of hypotheses
% Nuanced conclusions about context-dependent choices

\subsection{Best Practices and Recommendations}
% Universal principles that emerged
% Language-specific recommendations
% Organizational considerations for technology choice

\subsection{Limitations and Future Work}
% What we couldn't cover
% Additional languages worth investigating
% Emerging defensive technologies
% The ongoing evolution of the threat landscape

\subsection{Reflection}
% Personal learnings from the investigation
% Implications for future development work

\newpage

\bibliographystyle{plain}
\bibliography{out/references}

\end{document}

